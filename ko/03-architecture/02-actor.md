---
title: Actor Model
sidebar_position: '2'
---

# 컨트랙트 호출에서 액터 모델

[액터 모델](https://en.wikipedia.org/wiki/Actor_model)은 디자인 패턴으로 신뢰할 수 있는 분산 시스템을 만드는데 사용합니다. 기본 포인트는 각 `Actor`는 자신의 내부 상태에 대한 독점적인 접근 권한을 가지며 `Actor`끼리 서로 호출할 수 없다는 것입니다. 대신 일부 `Dispatcher`(시스템 상태를 유지하고 코드와 스토리지를 매핑한다)를 통해 메시지들을 보냅니다. 기본적으로 `Actor` 패턴을 아래의 인터페이스에서 캡슐화할 수 있습니다:

```rust
pub trait Actor {
  fn handle(msgPayload: &[u8]) -> Vec<Msg>;
}

pub struct Msg {
  pub destination: Vec<u8>,
  pub payload: Vec<u8>,
}
```

이것은 CosmWasm에서 컨트랙트를 모델링하는데 사용하는 기본 모델입니다. 아래의 함수도 같은 영향을 확인할 수 있습니다.

```rust
pub fn handle<T: Storage>(store: &mut T, params: Params, msg: Vec<u8>) -> Result<Response>
```

응답은 `Vec<Msg>`과 약간의 메타데이터를 포함합니다. `store`은 컨트랙트의 내부 상태에 접근합니다. 그리고 `params`는 글로벌한 불변 컨텍스트입니다. 그래서 같은 디자인에 대한 약간의 구문만 다른 것입니다. 이 기본 디자인으로부터 몇 가지 유용한 점들을 가져올 수 있습니다:

- 첫 번째, 액터 간 데이터 패킷 형식으로 제한되는 **느슨한 결합**이 있습니다(수신자가 송신자가 보낸 상위 집합을 지원해야 합니다). 여기에는 복잡한 API나 넘겨줄 함수 포인터들이 없습니다. REST나 RPC 호출을 서비스 간 경계로 사용하는 것과 유사하며, 많은 사용자로부터 시스템을 확장할 수 있게 구성하는 방법입니다.

- 둘째, 각 `Actor`는 자체 큐를 사용해 자신의 쓰레드에서 효율적으로 실행할 수 있습니다. 이것은 각 액터(우리가 의존하는) 내에서 동시성(아직 CosmWasm에서 사용하지 못합니다...)과 **순차 실행**을 지원해줍니다. 위의 `Handle` 메소드가 이전에 실행된 `Handle` 메소드의 중간에 실행이 불가함을 의미합니다. `Handle`은 동기 호출이며 `Actor`가 다음 메시지를 처리하기 전에 반환합니다. 이 기능은 [디자인으로 재진입 공격으로부터 우리를 보호합니다](./smart-contracts#avoiding-reentrancy-attacks).

CosmWasm과 관련된 다른 중요한 측면은 **지역성**입니다. 즉, 액터는 **이전에 자신이 받았던 주소의 액터들과만 소통할 수 있습니다**. 우리는 다음 페이지에서 [이름과 주소](./addresses)에 대해 더 깊숙히 들어갈 건데요, 핵심은 두 액터가 소통하는 것이 아니라, 외부 메시지(컨트랙트 생성자나 잠재적인 사용자로부터)가 액터로 무조건 송신이 되어야 한다는 것입니다. 이를 통해 분산 방식으로 망 구성 방식(topology)를 유연하게 설정할 수 있습니다. 다만 그러한 주소로 전달될 데이터 형식은 하드코딩 되어야만 합니다. 여러 표준 인터페이스들이 구축되면(ERC20, ERC721, ENS와 같은), 다른 코드를 가졌으나 공통 API를 공유하는 큰 컨트랙트 클래스간 결합성을 지원할 수 있습니다.

## 보안상 이점 {#security-benefits}

**개인 내부 상태(private internal state)**를 적용함으로써 주어진 컨트랙트는 내부 상태의 모든 유효한 트랜잭션을 보장할 수 있습니다. *다른 모듈의 스토리지에 읽고 쓸 수 있는 것*을 허용해 신뢰할 수 있는 모듈들이 생성자에 `StoreKey`를 넘겨주는 Cosmos SDK에서 사용된 기능 모델과는 대조적입니다. Cosmos SDK에서 우리는 모듈을 호출하기 전에 감사할 수 있고, 컴파일 타임에 강력한 권리들을 안전하게 넘길 수 있습니다. 하지만 스마트 컨트랙트 시스템에서 컴파일 타임에 체크할 수 없고 우리는 컨트랙트 사이의 경계를 더 엄격하게 만들 필요가 있습니다. 이렇게 하면 컨트랙트의 상태 내부의 모든 가능한 전환에 대해 종합적으로 판단을 할 수 있습니다(그리고 이를 빠르게 테스트해 볼 수 있습니다)

위에서 언급한 것처럼, **순차 실행**은 컨트랙트 코드의 모든 동시 실행을 방지합니다. 전체 컨트랙트 코드에 대한 자동 뮤텍스와 같은 역할을 합니다. 동시 실행은 흔한 이더리움 공격 중 하나인 재진입을 만들기 때문에 문제입니다. 재진입은 컨트랙트 A가 컨트랙트 A를 호출하는 컨트랙트 B를 호출할 때 발생합니다. 컨트랙트 A의 첫 번째 호출에서 메모리 안의 로컬 변화(예를 들어 잔액을 차감하는 경우)는 지속되지 않아 두 번째 호출에서 오래된 상태를 두 번 사용할 수 있습니다(예를 들어 잔액 전송을 두 번 승인할 수 있습니다). 순차 실행을 강제함으로써 컨트랙트에서 나가기 전에 모든 변화를 스토리지에 반영하고, 다음 메시지가 처리될 때 올바른 상태를 제공합니다.

## 원자적 실행 {#atomic-execution}

메시지를 보내는 문제 중 하나는 두 컨트랙트에 대해 상태 변화를 원자성을 지키면서 커밋하는 것입니다. 상태를 커밋하기 전에 반환된 메세지가 적절히 처리되었는지 확인하고 싶은 경우가 많습니다. 분산 데이터베이스에서 사용되는 "three-phase-commit"과 같은 방법이 있지만, 보통의 경우라면 모든 액터가 같은 바이너리에 존재해 `Keeper`안에서 처리를 할 수 있습니다. 외부 트랜잭션으로부터 온 Msg를 처리하기 전에, 우리는 전역 데이터 저장소의 세이브포인트를 생성하고 첫번째 컨트랙트에 하위 집합을 전달합니다. 그런 다음 같은 하위 트랜잭션 내부에서 반환된 메세지들을 전부 실행합니다. 만약 모든 메시지가 성공했다면 우리는 하위 트랜잭션을 커밋할 수 있습니다. 만약 실패했다면(혹은 가스가 모자르거나), 실행을 중단하고 첫번째 컨트랙트가 실행되기 전으로 상태를 롤백합니다

이 방법은 롤백을 통해 오류 처리를 하여 코드 업데이트를 최적화 할 수 있습니다. 예를 들어 두 "ERC20" 토큰 간 거래하는 교환을 보면, 교환은 주문을 이행한 것으로 만들고 구매자에게 토큰 A와 판매자에게 토큰 B를 이동시키는 두 메세지를 반환할 수 있습니다. (ERC20 토큰들은 허용의 개념을 사용해 주인은 X개의 토큰을 교환시 주소에서 옮길 수 있도록 "허용"해줘야 합니다). 반환된 메세지들을 실행할 때, 구매자가 충분한 토큰 B를 가지고 있지 않음이 밝혀졌다고 합시다(혹은 허용이 충분하지 않았거나). 이 메세지는 실패할 것이고, 모든 결과는 다시 원래대로 돌아갈 것입니다. 트랜잭션은 실패하고, 주문은 이행된 것으로 되지 않았고 어느 토큰도 양도되지 않을 것입니다.

많은 개발자가 다른 컨트랙트를 실행 과정에서 직접 호출하고 에러를 다루는 것을 더 편하게 생각할 수 있지만, 이러한 *최적화된 업데이트 및 반환* 접근법을 통해 거의 모든 동일한 사례를 처리할 수 있습니다. 그리고 컨트랙트의 에러 처리 코드에 실수가 발생할 여지가 없습니다.

## 호스트 모듈 동적 링킹 {#dynamically-linking-host-modules}

**지역성**과 **느슨한 결합**은 우리가 다른 CosmWasm 컨트랙트와 링크할 필요가 없다는 것을 의미합니다. 우리는 Dispatcher가 주소를 가지고 있는 어느 곳이던 메세지를 보낼 수 있습니다. 예를 들어, Cosmos SDK 내의 네이티브 `x/supply` 모듈에 의해 처리되고, 네이티브 토큰들을 이동시키는 `SendMsg`를 반환할 수 있습니다. 우리가 결합성을 위한 표준 인터페이스를 정의했기 때문에, 코어 모듈로의 호출을 할 수 있는 인터페이스도 정의할 수 있고 (스테이크를 본드 혹은 언본드 한다거나...), 컨트랙트 생성자 안의 네이티브 모듈로 주소를 전달할 수 있습니다.

## 블록체인 간 메시지 {#inter-blockchain-messaging}

액터 모델은 다른 컨트랙트에 동기적 호출을 시도하지 않고 "실행될 것"이라는 메시지만 반환하기에, [IBC](https://cosmos.network/ibc)를 사용해 크로스-체인 컨트랙트 호출을 만들기 좋습니다. 여기서 유일한 주의점은 앞서 언급했던 *원자성을 만족하는 실행*이 더 이상 보장이 되지 않는다는 것입니다. 같은 dispatcher에 의해 다른 호출이 불리지 않으므로, 컨트랙트 자체에 중간 상태를 저장할 필요가 있습니다. 즉, IBC 호출의 결과가 알려지기 전까지 상태는 바뀔 수 없기 때문에 안전하게 적용되거나 취소될 수 있습니다.

예를 들어, 체인 A에 체인 B로 토큰을 옮기고 싶을 때, 우리는 먼저 준비해야 합니다:

1. 컨트랙트 A가 송신자의 토큰의 양을 감소시킵니다.
2. 컨트랙트 A는 IBC 메시지의 id, 송신자, 수신 체인에 연결된 토큰들의 "에스크로"를 만듭니다.
3. 컨트랙트 A는 상태를 커밋하고 체인 B로의 IBC 트랜잭션을 초기화하기 위해 메세지를 반환합니다.
4. 만약 IBC의 송신 부분이 실패하면, 위의 컨트랙트는 원자성을 만족하며 취소됩니다.

시간이 지난 후, "성공" 혹은 "에러"/"타임아웃" 메시지가 IBC 모듈로부터 토큰 컨트랙트로 반환됩니다.

1. 컨트랙트 A는 메세지가 IBC 핸들러로부터 온 것인지 확인하고(인증) 에스크로에 있는 알려진 IBC 메세지 ID를 참조합니다.
2. 만약 성공이라면, 에스크로는 삭제되고 에스크로 된 토큰은 "체인 B"의 계정에 생깁니다(즉, 향후 IBC 메세지들은 체인 B에서만 생성할 수 있습니다).
3. 만약 에러였다면, 에스크로는 삭제되고 에스크로된 토큰은 송신자의 계정에 돌아갑니다.

NFT 소유권을 옮기기, 크로스-체인 스테이킹 등도 비슷한 과정으로 생각할 수 있습니다. Cosmos SDK의 IBC 코드가 안정화되면(그리고 릴리즈에 포함되고) 이러한 가능성들을 확장하고 적절한 설계를 할 수 있는 도구들을 제공할 수 있겠지만, 컨트랙트의 설계는 이를 염두해두고 만들어집니다.

## 크레딧 {#credits}

재진입 공격을 피하기 위해 액터 모델을 사용하는 설계를 고안한 [Aaron Craelius](https://github.com/aaronc)에게 감사드립니다.
