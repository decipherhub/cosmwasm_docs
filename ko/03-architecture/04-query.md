---
title: Querying
sidebar_position: '4'
---

# 컨트랙트 상태를 쿼리하기

컨트랙트의 상태를 확인하고 싶은 경우가 많습니다. 외부 클라이언트(cli 사용)뿐 아니라 컨트랙트를 실행하는 동안에도 확인하고 싶으실 것입니다. 예를 들어, 저번 섹션에서는 "Alice" 또는 "Bob"과 같이 다른 컨트랙트에 대한 쿼리가 필요한 경우를 다뤘습니다. 먼저 쿼리의 두 가지 유형 - 원본 및 커스텀 - 을 다룬 다음 *외부 클라이언트* 와 *내부 클라이언트* (또 다른 컨트랙트)를 통한 쿼리의 의미를 살펴볼 예정입니다. 실제로 어떻게 작동하는지 살펴볼 뿐만 아니라 한 컨트랙트에서 다른 컨트랙트로 쿼리를 실행할 때 발생하는 디자인 및 보안 문제도 살펴보겠습니다.

**참고:** 본 문서는 상호 컨트랙트 쿼리(cross-contract queries)를 완벽하게 지원하는 CosmWasm 0.8에 맞게 업데이트되었습니다.

## Raw 쿼리 {#raw-queries}

실행하기 가장 간단한 형태의 쿼리는 키-값 스토리지에 대한 raw 읽기 액세스입니다. 만약 호출자(외부 클라이언트 또는 다른 컨트랙트)가 컨트랙트 스토리지에 사용되는 raw 바이너리 키를 전달하면, raw 바이너리 값을 쉽게 반환할 수 있습니다. 이 방법은 구현이 매우 쉽고 보편적이라는 장점이 있습니다. 단점은 호출자가 저장소의 *구현*에 연결되고 실행 중인 컨트랙트에 대한 구체적인 이해가 필요하다는 것입니다.

Raw 쿼리는 `wasmd` 런타임 내에서 구현되고 VM을 우회합니다. 결과적으로, CosmWasm 컨트랙트의 지원이 필요하지 않고 모든 컨트랙트의 상태가 공개됩니다. 이러한 `query_raw` 함수는 모든 호출자(외부 및 내부)에게 노출됩니다.

## 커스텀 쿼리 {#custom-queries}

{em0}구현{/em0} 에 밀접하게 결합되어 있는 것은 바람직하지 않은 경우가 많으며 그보다는 오히려 *인터페이스*에 의존해야합니다. 예를 들어 컨트랙트를 호출하기 위해 'ERC20'{code1}HandleMsg{/code1}에 대한 표준을 정의하고 {code2}QueryMsg{/code2}에 대해 이러한 표준을 정의하려고 합니다. 예로, 주소별 잔액을 쿼리하거나 수여자(granter)와 수령자(grantee)에 의한 allowance를 쿼리, 토큰 정보(티커, decimal 등)를 쿼리할 수 있습니다. 표준 *인터페이스*를 정의함으로서 복잡한 컨트랙트를 포함한 여러 구현체를 허용할 수 있습니다. "ERC20" 인터페이스는 가능한 기능에 아주 작은 일부분일 뿐입니다.

커스텀 쿼리를 실행하기 위해, 읽기 전용 모드로 데이터 저장소에 접근할 수 있는 `query` 함수 노출을 각 컨트랙트에 허용해야합니다. 이는 원하는 어떤 데이터든 가져올 수 있고, 심지어 계산도 수행할 수 있습니다. 이 메소드는 모든 호출자(외부 및 내부) 에게 `query_custom`으로 노출됩니다. 데이터 포맷(쿼리와 응답 모두)은 컨트랙트가 원하는 어떤 것이던 될 수 있고, `HandleMsg` 및 `InitMsg`와 함께 공개 스키마에 적혀져야 합니다.

컨트랙트를 실행하면 무한한 양의 가스가 소모될 수 있기에 주의해야 합니다. `query_raw`는 하나의 키를 읽기 때문에 거의 고정적이고 적은 비용이 들지만, 이러한 쿼리에도 가스 리밋을 적용해야 합니다. 이것은 외부 및 내부 호출에 대해 다르게 수행되며 아래에서 설명하겠습니다.

## 외부 쿼리 {#external-queries}

외부 쿼리는 모든 웹 및 cli 클라이언트가 블록체인과 작용하는 전형적인 방식입니다. Cosmos SDK에서 `abci_query`를 호출하는 Tendermint RPC를 호출하며, Cosmos SDK는 이를 처리하기 위해 모듈에 위임합니다. 쿼리는 한 개의 노드에서 실행되기 때문에 가스제한이 없고 전체 블록체인을 느리게 만들지도 않습니다. 일반적으로 밸리데이터 노드에는 구현되어 있지 않은 기능입니다. 현재 SDK에 있는 쿼리 기능은 하드 코딩되어 있으며 개발자가 설계한 실행시간 제한이 있어서 어뷰징을 제한할 수 있습니다. 그렇다면 누군가가 무한 루프를 가진 wasm 컨트랙트를 업로드한 다음 쿼리를 노출한 퍼블릭 RPC 노드에 DoS공격을 하면 어떻게 될까요?

이러한 문제를 방지하기 위해, 외부에서 호출되는 모든 `query_custom` 트랜잭션에 대해 고정된 가스 한도를 정해야 합니다. 고정 가스 한도는 수수료를 부과하지 않고 어뷰징을 제한하는 데 사용됩니다. 무료 퍼블릭 노드는 소액을 선호하기 때문에 기준값을 정의하기 어렵지만, 아카이브 노드를 동기화하고 복잡한 쿼리를 수행하고 싶은 경우도 있습니다. 따라서 모든 `query_custom` 호출에 대한 가스 한도는 앱별 구성(configuration) 파일에서 정의할 수 있으며, 이는 합리적인 기본 한도로 각 노드 운영자가 정할 수 있습니다. 이를 통해 퍼블릭 노드는 복잡한 쿼리로부터 자신을 보호할 수 있으면서, 특별하게 설정된 노드는 몇 가지 쿼리로 모든 컨트랙트 데이터에 대해 대규모 집계를 수행할 수 있습니다.

`abci_query` 호출은 모듈의 현재 "진행 중" 상태를 절대 읽지 않고, 최근 커밋된 블록 이후 상태의 읽기 전용 스냅샷을 사용하는 것을 주의하세요.

## 내부 쿼리 {#internal-queries}

컨트랙트 간 많은 상호 작용은 메시지를 전송해 쉽게 모델링할 수 있지만, 상태를 변경하지 않고 다른 모듈들을 동기적으로 쿼리하고 싶은 경우도 있습니다. 예를 들어 [Address](03-addresses.md)를 통해 이름을 확인하려는 경우나 작업을 활성화하기 전에 일부 계정(다른 컨트랙트의)의 KYC 상태를 확인하려는 경우입니다. 이것을 일련의 메시지로 모델링할 수는 있지만 매우 복잡하며 간단한 use-case도 사용할 수 없게 만듭니다.

그러나 이 디자인은 [actor model](02-actor.md)의 주요 원칙 중 하나인 각 컨트랙트는 자체 내부 상태에 독점적으로 액세스할 수 있다를 위반합니다. (이 점에서 `query_custom`와 `query_raw`도 둘 다 실패입니다). 이론적인 문제 말고도, 이것이 올바르게 처리되지 않으면 동시성 및 재진입 문제로 이어질 수 있습니다. 저희는 안전에 중요한 이슈를 컨트랙트 개발자에게 전가하고 싶지 않고, 오히려 플랫폼에서 보안을 보장하고 싶습니다. 그러나 오래된 데이터를 제공하는 것도 많은 오류와 버그가 발생시킬 수 있습니다. 특히, *컨트랙트의 잔액을 쿼리하는 것을 포함해* 네이티브 SDK 모듈과 상호작용하기 위해 동일한 `Querier` 를 사용할 때 특히 그렇습니다.

따라서 현재 *CosmWasm 메세지를 실행하기 직전*의 상태를 스냅샷하기 위한 읽기 전용 액세스 권한의 `Querier`를 제공합니다. 우리가 스냅샷을 찍고 실행 컨트랙트와 쿼리된 컨트랙트 모두 *컨트랙트 실행 전* 데이터에 대한 읽기 전용 접근 권한을 갖기 때문에 이것은 Rust의 빌림 규칙(보안 설계자로서)에서 여전히 안전합니다. 현재 컨트랙트는 캐시에만 쓰고 나중에 성공하면 플러시됩니다.

재진입을 피해야 하는 것도 문제입니다. 이러한 쿼리는 동기적으로 호출되기 때문에 호출 컨트랙트를 다시 호출하여 문제를 일으킬 수 있습니다. 쿼리에는 읽기 전용 액세스 권한만 있고 부작용을 가질 수 없어, 원격 컨트랙트를 동기적으로 실행하는 것만큼 위험하지는 않지만 여전히 고려해야 할 문제입니다. 특히, 쿼리는 현재 실행 전의 상태에만 접근할 것입니다. 의도적으로 잘못된 데이터를 반환하는 쿼리 함수보다 더 많은 오류가 발생하지는 않겠지만 더 살펴볼 필요가 있습니다.

모든 쿼리는 이미 가스 제한이 있는 트랜잭션의 부분으로 수행되므로 여기서 추가 작업이 필요하지 않습니다. 쿼리의 일부로 수행된 모든 스토리지 읽기 및 데이터 처리는 나머지 트랜잭션과 동일한 가스 수준에서 차감되므로 처리 시간도 제한됩니다. 저희는 재진입이나 쿼리의 최대 깊이에 대한 명시적인 보호 장치를 추가하는 것을 고려했지만 `wasmd`에 아직 적용하지 않았습니다. 크로스-컨트랙트 쿼리에 대한 더 많은 작업이 결실을 맺게 되면, 이 부분은 더 연구가 될 것입니다.
